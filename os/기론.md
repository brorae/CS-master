# 운영체제란

사용자 모드와 커널모드의 사이에 있는 인터페이스

# 프로세스 vs 스레드

**프로세스**

메모리에 올라가있는 실행중인 프로그램

**스레드**

실제 프로세스의 실행 단위, 프로세스 한개가 여러 스레드를 가질 수 있다.

## 프로세스 주소 공간

코드 데이터 힙 스택

## 인터럽트(Interrupt)

하드웨어 인터럽트는 하드웨어의 동작 중에 발생하는 이벤트를 처리하기 위해 발생하는 인터럽트입니다. 예를 들어, CPU의 외부 인터럽트, 타이머 인터럽트, 입출력 장치 인터럽트 등이 있습니다.

소프트웨어 인터럽트는 프로그램 실행 중에 명령어 실행 순서를 바꾸어 처리해야 할 때 발생하는 인터럽트입니다. 예를 들어, 시스템 콜, 예외 처리, 프로세서 간 통신 등이 있습니다.

## 시스템 콜(System Call)

커널모드로 들어가기 위한 호출. 하드웨어의 기능을 사용하기 위해서 호출한다.

## PCB와 Context Switching

프로세스마다 고유한 PCB를 가지며 PID, 상태, PC를 가지고 있으며 커널모드에 있다.

컨텍스트 스위칭은 하나의 프로세스가 CPU를 점유하고 있을 때, 다른 프로세스가 CPU를 사용해야 할 경우, 운영체제는 현재 프로세스의 상태를 PCB에 저장하고, 다음에 실행할 프로세스의 상태를 PCB에서 읽어 레지스터에 복원한 후에 CPU를 할당합니다.

이를통해 여러개의 프로세스 실행 가능하다.

# IPC(Inter Process Communication)

다른 프로세스와 데이터를 주고받거나 서로간의 상호작용을 하는 기법을 말한다. 이를 통해 여러 개의 프로세스들이 서로 정보를 주고 받고, 조작하는 것이 가능하다.

IPC기법의 예시) 파이프, 메시지 큐, 공유 메모리, 소켓

# CPU 스케줄링

프로세스들이 한정된 CPU를 사용해야하므로 CPU 스케줄링이 필요하다.

# 데드락(DeadLock)

교착 상태에 빠져있어서 서로가 서로의 자원을 얻기를 기다리는 현상

# Race Condition

임계영역에 대해 여러 프로세스/스레드가 접근할 때, 순서에 따라 결과가 달라지는 현상

# 세마포어(Semaphore) & 뮤텍스(Mutex)

세마포어는 임계 영역에 여러 자원이 들어갈 수 있을 경우 사용하기 적합하다. 임계 영역의 개수를 카운팅하여 들어 갈 수 있는 자원의 개수를 알려준다.

뮤텍스는 자원이 임계 영역에 들어갈때, 락을 걸고 들어가서 다른 자원은 앞의 자원이 임계 영역에서 나올때까지 대기한다.

# 페이징 & 세그먼테이션 (PDF)

프로세스마다 가상 메모리를 가진다.

페이징(Paging)과 세그멘테이션(Segmentation)은 가상 메모리(Virtual Memory)의 구현 방식입니다.

페이징은 프로세스를 일정한 크기의 페이지로 분할하고, 물리 메모리를 고정된 페이지 단위로 할당하여 가상 메모리를 구현하는 방법입니다. 이를 통해, 내부 단편화가 발생할 수 있다.

세그멘테이션은 프로세스를 세그멘테이션 단위로 분할하고, 물리 메모리를 세그먼트 단위로 할당하여 가상 메모리를 구현하는 방법입니다. 따라서 외부 파편화가 발생할 수 있다.

페이징은 물리적 메모리를 페이지라는 고정 크기 블록으로 분할하고, 논리적 메모리를 페이지 단위로 분할하여 매핑하는 방식입니다. 각 페이지에는 페이지 번호가 할당되고, 페이지 번호는 페이지 테이블에서 물리적 메모리 주소와 매핑됩니다. 페이징은 논리적 메모리 공간을 연속된 물리적 메모리 공간으로 매핑하기 때문에, 내부 단편화가 발생할 수 있습니다.

세그멘테이션은 논리적 메모리를 서로 다른 크기의 논리적 단위인 세그먼트로 분할하고, 물리적 메모리에는 세그먼트의 크기와 동일한 단위인 프레임으로 분할하여 매핑하는 방식입니다. 각 세그먼트에는 세그먼트 번호가 할당되고, 세그먼트 번호는 세그먼트 테이블에서 물리적 메모리 주소와 매핑됩니다. 세그멘테이션은 논리적 메모리 공간을 논리적인 단위로 분할하기 때문에, 외부 단편화가 발생할 수 있습니다.

# 페이지 교체 알고리즘

페이지 교체 알고리즘은 메모리 내부에서 페이지 부재가 발생하였을 때 어떤 페이지를 메모리에서 내보낼 것인지 결정하는 알고리즘입니다. 페이지 교체 알고리즘은 다양한 종류가 있으며, 각각의 알고리즘은 다른 기준을 사용하여 페이지를 교체합니다.

1. FIFO(First In First Out)
   가장 오래전에 메모리에 올라온 페이지를 먼저 내보내는 알고리즘입니다. 단순하고 구현이 쉬우며, 페이지 부재율이 낮은 경우 효율적입니다. 그러나 최근에 사용된 페이지가 내보내지지 않아 페이지 부재율이 높아질 수 있습니다.
2. LRU(Least Recently Used)
   가장 최근에 사용하지 않은 페이지를 교체하는 알고리즘입니다. 최근에 사용된 페이지를 유지하기 때문에 페이지 부재율이 낮아지는 효과가 있습니다. 그러나 페이지를 교체할 때마다 모든 페이지의 사용 여부를 확인해야 하므로 오버헤드가 발생할 수 있습니다.
3. LFU(Least Frequently Used)
   사용 빈도가 가장 적은 페이지를 교체하는 알고리즘입니다. 최근에 사용된 페이지가 여러 번 사용되었다 하더라도 사용 빈도가 적은 페이지는 교체됩니다. 그러나 페이지 사용 빈도를 계속 추적해야 하므로 오버헤드가 발생할 수 있습니다.
4. NRU(Not Recently Used)
   최근에 사용되지 않은 페이지를 교체하는 알고리즘입니다. 페이지에 대한 사용 여부와 최근에 사용된 시간을 추적합니다. 추적한 시간이 오래된 페이지를 우선적으로 교체합니다.
5. Second-Chance
   FIFO 알고리즘을 기반으로 하되, 최근에 사용된 페이지를 교체하지 않는 알고리즘입니다. FIFO 큐에서 페이지를 꺼내면서 사용 여부를 확인하고, 최근에 사용된 페이지는 다시 FIFO 큐의 뒤쪽에 넣어줍니다. 이후 FIFO 알고리즘과 동일하게 페이지를 교체합니다.

# 메모리(Memory)

# 파일 시스템

파일 시스템(File System)은 컴퓨터에서 파일을 쉽게 저장, 검색, 삭제할 수 있도록 관리하는 체계입니다.

파일 시스템은 디렉토리 구조와 파일의 이름, 위치, 크기, 액세스 권한 등의 정보를 추적합니다. 이러한 정보를 토대로 파일을 쉽게 찾아 사용할 수 있습니다.

파일 시스템은 사용자가 파일을 생성, 복사, 이동, 삭제하는 작업을 지원합니다. 이러한 작업은 파일 시스템이 관리하는 메타 데이터(metadata)를 수정하여 수행됩니다. 파일 시스템은 또한 파일 시스템의 공간을 적절히 할당하고 파일 시스템을 디스크의 섹터에 맞게 배치하여 파일을 저장합니다.