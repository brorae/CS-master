
# 운영체제란?

* 유저와 하드웨어 사이의 중계자
* 메모리, 프로세스, 저장장치와 같은 자원 제어 및 관리 (인터페이스 역할)

# 프로세스 vs 스레드

### 프로세스

* 하드웨어에 적재된 프로그램을 실행시켜 메모리에 올라가 CPU의 할당을 받을 수 있는 것을 말한다.
* 프로세스가 생성될 때 PCB도 함께 생성된다.

### 스레드

* 프로세스의 실행 흐름으로 프로세스 한 개당 여러개의 스레드를 가질 수 있다. 스레드끼리는 프로세스의 자원을 공유할 수 있다.

### 멀티프로세스 대신 멀티스레드를 사용하는 이유는?

1. 프로세스간의 컨텍스트 스위칭 오버헤드 
   * 프로세스는 프로세스마다의 독립적인 메모리를 가지고 있으므로 빈번한 컨텍스트 스위칭으로 인한 성능 저하가 발생
   * 스레드를 활용하면 빠른 컨텍스트 스위칭 가능

2. 프로세스간 통신의 어려움

   * 프로세스는 독립적인 메모리 주소공간을 가지고 있기 때문에 통신하기 어려움.

   * 스레드는 Heap, Static, Code 영역을 공유하므로 통신을 빠르고 쉽게 가능함.

### 멀티스레드 vs 싱글 스레드

#### 멀티스레드

* 장점
  * 응답성 증가 - 프로그램의 일부분이 중단되거나 긴 작업을 수행하더라도 다른 스레드를 통해 프로그램이 계속 수행됨.
  * 경제성 - 프로세스 내 자원들과 메모리를 공유하기 때문에 메모리 공간과 시스템 자원 소모가 줄어든다.
  * 멀티 프로세서 활용 - 병렬성 증가
* 단점
  * 싱글 코어 멀티 스레딩은 컨텍스트 스위칭, 동기화 등의 이유로 싱글 스레드보다 느리다.
  * 동기화가 필요하다.
  * 멀티 스레딩을 위해 운영체제의 지원이 필요하다.
  * 프로그래밍 난이도가 높다.

#### 싱글 스레드

* 장점
  * 컨텍스트 스위칭이 일어나지 않는다.
  * 자원에 대한 동기화를 신경쓰지 않아도 된다.
  * 단순히 CPU만을 사용하는 계산 작업이라면 멀티스레드 보다 싱글스레드로 프로그래밍하는 것이 더 효율적일 수 있다.
  * 프로그래밍 난이도가 쉽다.
* 단점
  * 멀티 코어 CPU를 활용하지 못한다.
  * 연산량이 많은 작업일 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다.
  * 에외나 에러처리를 해주지 못하면 프로그램이 멈춘다.

### 멀티스레드와 싱글스레드는 각각 언제 활용해야하는가?

* 싱글스레드 - 싱글코어인 경우, 단일 명령 시퀀스 프로그램인 경우 (계산기, 텍스트 편집기, 콘솔 프로그래밍), CPU bound 프로그램인 경우(영상 편집, 머신러닝)
* 멀티스레드 - I/O bound 프로그램인 경우(일반적인 백엔드 API 서버)
* CPU bound - CPU burst가 많은 프로세스(프로세스가 CPU에서 한번에 연속적으로 실행되는 시간)
* I/O bound - I/O burst가 많은 프로세스(프로세스가 IO 작업을 요청하고 결과를 기다리는 시간)

# 프로세스 주소 공간

* 코드 - 프로세스가 실행할 코드가 기계어의 형태로 저장된 공간
* 데이터 - 전역변수, static 변수 등이 저장된 공간
* 힙 - 개발자에 의해 공간이 동적으로 할당 및 해제, 주로 참조형 데이터 등의 데이터가 할당된다.
* 스택 - 호출된 함수의 수행을 마치고 복귀할 주소, 지역변수, 매개변수, 리턴값 등을 저장하는 공간

# 인터럽트(Interrupt)

* 하드웨어 인터럽트
  * 장치 컨트롤러 등 하드웨어 장치가 인터럽트 라인을 세팅  (I/O 작업, 타이머 인터럽트)
* 소프트웨어 인터럽트
  * 트랩이라고도 불림
  * 예외상황 - 0으로 나누는 연산 등 비정상적인 작업, 자신의 메모리 영역 바깥에 접근하려는 시도 등
  * 시스템 콜 - 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법

# 시스템 콜(System Call)

운영체제는 커널모드와 사용자모드로 나뉜다. 프로그램이 구동됨에 있어 파일을 읽거나, 쓰거나, 메시지 출력 등의 많은 부분들은 커널모드에서 사용한다. 커널 내에는 커널모드의 기능들을 사용할 수 있도록 만들어둔 함수들이 있는데 사용자 모드에서 이를 호출하는 것을 시스템 콜이라고 한다. 프로세스가 하드웨어에 접근해서 필요한 기능을 사용할 수 있게 해준다.

# PCB와 Context Switching

### PCB

운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조이다. 

PCB에는 PC, 스케줄링 알고리즘 ,프로세스 상태, 레지스터 값 등이 포함된다. 

PCB는 커널의 데이터 영역에 존재한다.

### 컨텍스트 스위칭

* 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 **CPU의 제어권이 이양되는 과정.**
* 타이머 인터럽트가 발생했을 경우
* 입출력 요청을 통해 기존 프로세스가 봉쇄상태로 바뀌는 경우
* 단순 시스템 호출과 같은 인터럽트는 컨텍스트 스위칭으로 보지 않는다. 

### 프로세스 컨텍스트 스위칭이 스레드 컨텍스트 스위칭에 비해 오버헤드가 나는 이유는?

#### 프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭

- 공통점
  - 커널모드에서 실행
  - CPU 레지스터 상태를 변경 (PC, Stack pointer 등) 
- 차이점
  - 프로세스 컨텍스트 스위칭에서는 가상 메모리 주소 관련 처리를 추가로 수행
  - MMU를 스위칭된 프로세스의 메모리 보도록 갱신 & TLB 비워줌 (MMU 안에 TLB가 포함)
  - 이작업을 안해주면 다른 프로세스의 공간에 침입할 수 있음
  - 프로세스의 컨텍스트 스위칭이 발생하면 CPU 내의 캐시메모리에 다른 프로세스들의 전혀 상관없는 데이터들이 적재되기 때문에 캐시가 효율이 낮아지는 경우가 생긴다. 이를 캐시 오염이라고 한다. 이를 해결하기 위해 일부 CPU들은 프로세스 컨텍스트 스위칭 시 캐시메모리를 비워주기도 한다.

#### 결론 - 메모리 주소 관련 처리를 안해줘도 되기 때문에 스레드 컨텍스트 스위칭이 빠르다.

# IPC(Inter Process Communication)

* 파이프 방식
  * 익명 파이프 - 부모와 자식간의 파이프를 만들어 통신하는 방법. 하나의 프로세스는 쓰기만하고, 나머지 프로세스는 읽기만 할 수 있다.
  * Named 파이프 - 전혀 모르는 프로세스 간의 통신 가능.
  * 둘다 반이중 통신이기 때문에, 파이프를 2개씩 만들어줘야함. 따라서 비효율적일 수 있다.
* 공유 메모리
  *  **프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용**
  *  **중개자 없이 곧바로 메모리에 접근할 수 있어서 IPC 중에 가장 빠르게 작동함**
* 메시지 큐
  * 커널의 중계를 통해 메시지를 전달하며 큐를 사용하여 비교적 안전하다.
  * Queue에 저장하고 꺼내고 하는 과정에서 발생하는 Overhead로 인해 효율성은 떨어진다.
  * 비동기로 처리할 수 있다.
  * 서버가 죽었을 때, 메시지 큐의 데이터로 처리 가능.

# CPU 스케줄링

### 스케줄링이 필요한 이유는?

프로세스들이 한정된 CPU를 사용해야하므로 CPU 스케줄링이 필요하다. CPU를 효율적으로 활용하며 불이익을 당하는 프로세스가 없도록 하기 위함이다.

### 종류

* FCFS
  * 콘보이 현상 - CPU 버스트 시간이 긴 프로세스가 먼저 도착하면 뒤에 있는 짧은 프로세스는 오래 기다려야하는 현상
* SJF
  * 평균 대기 시간이 짧지만, 기아현상이 나타날 수 있음.
* RR
  * CPU를 할당받을 수 있는 시간을 제한하는 방식, 시간이 경과하면 다른 프로세스에게 CPU 할당
  * 할당시간이 너무 길면 FCFS
  * 할당시간이 너무 짧으면 문맥교환의 오버헤드가 커짐
  * 모든 프로세스는 (n-1)*q 시간 이내에 적어도 한번은 CPU를 할당 받을 수 있게 됨.
  * 라운드 로빈 방식은 공정함. → CPU를 쓰고자 하는 양이 적으면 소요시간이 짧아지고, 반대로 CPU를 쓰고자 하는 양이 많으면 소요시간도 거기에 비례해서 길어진다. (대기시간도)
* EDF
  * 마감기한이 임박한 프로세스부터 처리하는 방식 (선점)

# 데드락(DeadLock)

두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있어 다음단계로 진행하지 못하는 상태

### 발생조건

* 상호배제 - 한 프로세스가 자원을 사용하고 있으면, 다른 프로세스는 사용할 수 없다.
* 점유대기 - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
* 비선점 - 다른 프로세스가 사용하고 있는 자원은 끝날 때까지 강제로 뺏을 수 없다.
* 순환대기 - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야한다.

### 해결방법

* 예방
  * 4가지 중 한가지를 만족하지 않도록 함
  * 상호배제 조건 방지: 한번에 여러 프로세스가 공유자원을 사용할 수 있게 한다. 프린터같은 경우에는 적용하지 못한다.
  * 점유대기 조건 방지: 프로세스가 작업 수행전에 필요한 자원을 모두 요청하고 획득해야한다. 이렇게 되면 자원의 효율성이 떨어진다. 예를 들면, 시험전에 책 3권으로 공부할 예정인데 책 3권중 1권이 아직 배송중이라 그 책 한권이 도착할때 까지 공부하지 않고 기다린다.
  * 비선점 조건 방지: 이미 할당된 자원에 선점권이 없어야한다. 하지만 비선점 조건 사용시 어떤 프로세스든 중간에 해당 자원을 사용할 수 있어서 기존에 사용중이던 작업 내용을 잃을 수도 있다.
  * 순환대기 방지: 모든 자원에 순서를 부여해서 오름차순으로만 자원을 요청할 수 있게 한다. 하지만, 이 조건을 사용하면 필요 자원은 훨씬 오래전부터할당 받은 상태가 되야 하므로 자원 낭비가 일어난다.

* 회피

  * 예방법은 비효율적이기 때문에 나온것이 회피이다.

    ### 은행원 알고리즘 

    * 미리 설정된 모든 자원들의 할당량을 가지고 시뮬레이션을 통해 safe state에 들 수 있는지 검사한다. 즉, 대기중인 프로세스들의 활동에 대해서 교착상태 가능성을 미리 조사한다. 
    * safe state - 프로세스들이 자원을 요청할 때, DeadLock을 발생시키지 않으고 모두에게 할당해 줄 수 있는 상태
    * safe sequence - deadlock이 발생하지 않는 순서
    * 단점
      * 할당할 수 있는 자원의 수가 일정해야한다.
      * 사용자 수가 일정해야한다.
      * 최대 자원 요구량을 미리 알아야한다.
      * 프로세스들은 유한한 시간 안에 자원을 반납해야한다.

* 탐지 및 복구
  * 교착 상태 존재 여부 및 교착 상태에 연관된 프로세스와 자원을 알아낸다.
    * 자원 할당 그래프
  * 데드락을 일으킨 프로세스를 종료하거나, 할당된 자원을 해제(선점)함으로써 복구한다.

* 무시
  * 대부분 교착 상태는 드물게 발생하고 예방,회피,탐지 및 복구는 비용이 많이 들기때문에 그냥 무시하는 방식

# Race Condition

공유자원에 대해 여러 프로세스/스레드가 접근할 때, 순서에 따라 결과에 영향을 줄 수 있는 상태

멀티프로세스와 멀티스레드 환경에서는 race condition 없이 동기화 하는 것이 필요하다.

# 세마포어(Semaphore) & 뮤텍스(Mutex)

### 스핀락

락을 가질 수 있을 때까지 메서드를 호출하며 반복해서 시도하는 방법

기다리는 동안 CPU를 낭비한다.

### 뮤텍스

스핀락의 단점을 극복하기 위해 다른 스레드가 큐에서 대기하고 락이 풀리면 그 스레드를 깨우는 방법

여러 쓰레드, 프로세스에 의해 소유될 수 있는 Key를 활용하여 상호배제를 달성하는 기법 (lock, unlock)

### 세마포어

Signaling mechanism을 가진, 현재 공유자원에 접근할 수 있는 쓰레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법

# 페이징 & 세그먼테이션

### 페이징

프로세스는 메모리의 프레임들과 같은 크기인 페이지로 나누어짐(고정)

외부 단편화는 발생하지 않으나 프로세스의 마지막 페이지에서는 내부 단편화 발생 가능

### 세그먼테이션

프로세스는 여러 세그먼테이션으로 나누어짐(동적)

내부 단편화가 없고 메모리 효율을 올릴 수 있음

외부 단편화 발생 가능

# 페이지 교체 알고리즘

페이지 부재 발생 시 해당 페이지를 로드해야하는데 희생할 페이지를 결정하는 알고리즘

* FIFO
  * 메모리에 먼저 올라온 페이지를 먼저 내보내는 알고리즘
* OPT (최적화)
  * 앞으로 가장 사용하지 않을 페이지를 가장 우선적으로 내보내는 알고리즘
  * 페이지 부재의 횟수를 많이 감소시킬 수 있다.
  * 실질적으로 페이지가 앞으로 잘 사용되지 않을 것이라는 보장이 없기 때문에 수행하기 어렵다.
* LRU
  * 최근에 사용하지 않은 페이지를 가장 먼저 내보내는 알고리즘
  * 실제로도 최근에 사용하지 않은 페이지는 앞으로도 사용하지 않을 확률이 높다. 
* LFU
  * 과거에 참조횟수가 가장 적었떤 페이지를 쫓아내는 알고리즘

# 메모리(Memory)

### 가상메모리

프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

프로그램이 물리 메모리보다 커도 된다.

### MMU

* 논리주소를 물리 주소로 변환시켜준다.
* 메모리 보호나 캐시 관리 등 CPU가 메모리에 접근하는 것을 총 관리해주는 하드웨어

#### 역할

* MMU가 지원되지 않으면, physical address를 직접 접근해야 하기 때문에 부담이 있다.
* MMU는 사용자가 기억장소를 일일이 할당해야 하는 불편을 없애준다.
* 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수 있게 해준다.

### 캐시 메모리

메모리에 저장된 내용의 일부를 임시로 저장해두는 기억장치

CPU와 주기억장치의 속도차이로 성능 저하를 방지하기 위한 방법

### 지역성의 원리

기억 장치 내의 정보를 균일하게 접근하는 것이 아니라 한 순가에 특정 부분을 집중적으로 참조하는 특징

* 시간 지역성 - 최근에 참조된 주소의 내용은 곧 다음에도 참조되는 특성
* 공간 지역성 - 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성

# 파일 시스템

컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록 유지 및 관리하는 방법

### 접근 방법

1. 순차접근
   * 가장 단순한 방법으로 파일의 정보가 레코드 순서대로 처리된다.
2. 직접 접근
   * 파일의 레코드를 임의의 순서로 접근할 수 있다.
3. 색인 접근
   * 파일에서 레코드를 찾기 위해 색인을 먼저 찾고 대응되는 포인터를 얻는다.

### 디렉터리

* 1단계 디렉터리
* 2단계 디렉터리
* 트리 구조 디렉터리
* 그래프 구조 디렉터리