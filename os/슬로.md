운영체제란

컴퓨터 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 프로그램이다.



운영체제의 역할

- 사용자들이 컴퓨터 자원에 대해 신경 쓰지 않고, 컴퓨터를 쉽고 편하게 사용하도록 해준다.
  - 여러 사용자/프로그램이 각각 독자적으로 컴퓨터에서 수행되는 것 같은 환상 제공
  - 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행
- 프로세서, 메모리, 입출력 장치 등 컴퓨터 자원을 효율적으로 관리한다.



운영체제 구조

운영체제는 커널과 인터페이스로 이루어져 있다. 핵심은 커널인데, 커널은 컴퓨터의 전원이 켜지면 항상 메모리에 상주하는 프로그램이다. 좁은 의미에서 커널 자체를 운영체제라고 부르기도 하고, 커널 뿐만 아니라 각종 주변 시스템 유틸리티를 포함한 개념이 큰 의미에서의 운영체제이다.



유저 모드와 커널 모드를 구분해 놓은 이유

시스템에 중요한 영향을 미치는 연산은 커널 모드에서만 실행 가능하도록 함으로써 하드웨어의 보안을 유지하기 위해서이다.

- 유저 모드
  - 유저가 접근할 수 있는 영역을 제한적으로 두고, 프로그램 자원에 함부로 침범하지 못하는 모드이다.
  - 우리가 개발하는 프로그램은 일반적으로 유저 모드에서 실행
- 커널 모드
  - 모든 자원에 접근, 명령할 수 있다.



유저 모드와 커널 모드 전환 과정

프로세스가 실행되는 동안 프로세스는 수없이 유저 모드와 커널 모드를 왔다갔다 하며 실행된다.

- 프로그램 실행 중에 인터럽트가 발생하거나, 시스템 콜을 호출하게 되면 커널 모드로 전환한다. (유저 모드 -> 커널 모드)
- 커널 모드에서는 실행 중이었던 cpu의 상태를 저장한다. (커널)
- 커널이 인터럽트나 시스템 콜을 직접 처리한다. (커널)
- 처리가 완료되면 중단됐던 프로그램의 cpu 상태를 복원한다. (커널)
- 다시 통제권을 프로그램에게 전환한다. (커널 -> 유저)
- 기존에 중단되었던 부분부터 다시 실행한다. (유저)



인터럽트(Interrupt)

인터럽트란 프로세스 실행 중에 예외상황이 발생하여 처리가 필요한 경우, CPU에게 신호를 보내 처리할 수 있도록 하는 것을 말한다. 인터럽트는 크게 하드웨어 인터럽트, 소프트웨어 인터럽트로 나뉜다.

- 하드웨어 인터럽트
  - 하드웨어가 발생시키는 인터럽트로 시스템 버스를 통해 cpu에 신호를 보냄으로써 인터럽트를 발생시킨다.
- 소프트웨어 인터럽트
  - 트랩(Trap)이라고 부르고, 예외(exception)이나 시스템 콜(System call)로 트랩을 발생시킨다.



인터럽트가 발생하면 cpu에서는 즉각적으로 인터럽트 처리를 위해 커널 모드에서 커널 코드를 실행한다. 현재 실행 중인 명령어까지 완료한 뒤에 인터럽트 처리를 위해 커널이 통제권을 넘겨받는다.



인터러비트 종류

- 전원에 문제가 생겼을 때
- I/O 작업이 완료됐을 때
- 시간이 다 됐을 때(timer 관련)
- 0으로 나눴을 때
- 잘못된 메모리 공간에 접근을 시도할 때



인터럽트 과정

1. processA는 시스템 콜을 통해 인터럽트를 발생시킨다.
2. 현재의 상태를 해당 프로세스의 PCB(Process Control Block)에 저장한다.
3. PC(Program Counter)에 다음에 실행할 명령의 주소를 저장한다.
4. 인터럽트 백터를 이용해서 ISR(Interrupt Service Routine)의 주소를 알아내고, ISR을 실행한다.
   - 인터럽트 백터 : 인터럽트 발생 시, 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블이다.
   - 인터럽트 처리 루틴(ISR) : 해당 인터럽트를 처리하는 커널 함수
5. 인터럽트 종료 후, 기존 상태를 복구한다.
6. 기존의 프로세스를 계속 실행한다.



인터럽트가 왜 필요할까?

cpu와 I/O의 속도 차이를 극복하기 위해서 사용한다. (입출력 연산이 cpu 명령 수행 속도보다 현저히 느리기 때문)



시스템 콜(System Call)

사용자 프로그램이 운영체제의 서비스를 이용하기 위해서 운영체제에게 해당 서비스를 실행하도록 요청하는 것을 말한다. (사용자 프로그램이 운영체제 코드를 직접 실행하는 것이 불가능 하기 때문)

사용자 프로그램과 커널을 이어주는 인터페이스 역할을 한다.

시스템 콜이 발생하면, 해당 커널 코드가 커널 모드에서 실행된다.



시스템 콜의 종류

- 프로세스/스레드 관련
- 파일 I/O 관련
- 소켓 관련
- 장치(device) 관련
- 프로세스 통신 관련





프로세스 vs 스레드

프로세스

- 실행 중인 프로그램을 의미하고, 운영체제로부터 시스템 자원을 할당받는 단위
- 특징
  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)을 할당 받는다.
  - 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.
  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다.
  - 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신(IPC, Inter-Process Communication)을 사용해야 한다.
    - 동시에 접근 가능한 메모리 즉, 프로세스들이 공유하는 메모리가 필요하다는 뜻이다.
    - 따라서 컴퓨터 내부에서 보다 효율적으로 정보를 주고 받기 위한 통신의 일종이라고 생각하면 된다.
    - 인터넷 통신을 ipc의 확장으로 이해할 수 있다. (서버 클라이언트 통신과 유사하기 때문)

스레드

- 프로세스 실행 단위. 하나의 프로세스가 할당받은 자원을 여러 개의 스레드가 공유하며 사용할 수 있다.
- 특징
  - 스레드는 프로세스 내에서 각각 Stack 영역만 따로 할당받고 Code, Data, Heap 영역은 공유한다.
  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들(힙 공간 등)을 같은 프로세스 내에 스레드끼리 공유한다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 스레드도 변경 결과를 볼 수 있다.

멀티 프로세스

- 여러 개의 프로세스를 동시에 수행하는 것을 말한다.
- 장점
  - 독립된 구조를 가지기 때문에 안정성이 높다.
- 단점
  - 컨텍스트 스위칭을 위한 오버헤드가 발생하고, 많은 메모리 공간을 차지한다.

멀티 스레드

- 하나의 프로세스의 작업을 여러개의 스레드 단위로 분리해서 자원의 생성과 관리의 중복을 최소화하는 것을 말한다.
- 장점
  - 자원을 공유하기 때문에 컨텍스트 스위칭이 적고, 오버헤드가 작다.
- 단점
  - 프로세스 내부의 자원을 공유하기 때문에 동시에 자원에 접근했을 때, 문제가 발생할 수 있다.
  - 또한, 하나의 스레드가 자신의 데이터 공간을 망가뜨린다면, 해당 데이터를 공유하고 있는 모든 스레드에 문제가 발생한다.



프로세스 주소 공간

- 코드
  - 실행할 명령어를 기계어 코드로 저장되어 있는 공간
  - 프로그램이 수정되면 안되기 때문에 ReadOnly 상태로 저장되어 있다.
- 데이터
  - 프로그램에 필요한 전역 변수, 정적 변수 저장되어 있는 공간
  - 프로그램 시작과 함께 할당되고, 프로그램이 종료되면 소멸한다.
- 스택
  - 함수 호출에 필요한 지역 변수, 매개변수가 저장되는 공간
  - 함수 호출 시 할당되고, 함수 종료 시 소멸한다.
  - 재귀 함수가 너무 깊게 호출되거나 너무 많은 지역변수를 가지고 있으면 stack overflow 에러가 발생할 수 있다.
- 힙
  - 사용자가 관리하는 공간으로 메모리가 동적으로 할당되고 해제되는 공간
  - 주로 참조형 데이터가 할당된다.
  - JAVA에서는 GC가 메모리를 알아서 해제해준다.



프로세스 관리(PCB, Context Switching)

여러 프로세스가 함께 수행될 때는, 짧은 시간 동안 CPU를 사용하고 CPU를 선점당했다가 추후에 다시 CPU를 획득하는 방법으로 진행된다. 다시 CPU를 획득해서 명령을 수행자기 위해서는 이전에 어디까지 수행했는지를 정확하게 알아야한다. 이 때, 필요한 정보가 Context이다.

Context란?

- 프로세스가 현재 어떤 상태에서 수행되고 있는지를 정확히 규명하기 위해 필요한 정보를 의미한다. 즉, CPU가 해당 프로세스를 실행하기 위한 프로세스의 정보들이다.
- Context는 프로세스의 주소 공간(코드, 데이터, 스택), 레지스터의 값 등을 포함한다.
- Context는 크게 하드웨어, 프로세스의 주소 공간, 커널로 나눌 수 있다.
  - 하드웨어 Context
    - CPU 수행 상태를 나타냄
    - PC, 레지스터에 저장하고 있는 값
- Context는 프로세스의 PCB(Process Control Block)에 저장된다.

PCB(Process Control Block)

- 프로세스를 실행하기 위한 정보를 저장하는 자료구조를 말한다.
- 커널 주소공간의 data 영역에 존재한다.
- 저장 정보
  - PID : 프로세스의 고유 번호
  - PS : 프로세스의 상태 (준비, 대기, 실행 등)
  - PC : 다음에 수행할 명령어의 위치
  - CPU register : CPU 연산을 위해 필요한 값
  - 스케줄링 정보
  - 메모리 관리 정보
  - 자원 사용 정보
  - 입출력 상태 정보
  - 등등

컨텍스트 스위칭이란?

현재 진행중인 프로세스의 상태를 PCB에 저장하고 다음에 진행할 프로세스의 상태값을 읽어 레지스터에 적재하는 과정을 말한다.

- 언제 발생하지? - 인터럽트가 발생할 때
  - Time Quantm을 모두 소모 (CPU 사용 시간이 만료 되었을 때)
  - I/O 입출력 요청
  - fork a child (자식 프로세스를 만들 때)
- 컨텍스트 스위칭을 진행하는 동안 다른 작업을 할 수 없다. → 오버헤드의 원인이 된다.
- 시스템 콜이나 인터럽트로 인해 CPU 제어권이 운영체제로 넘어가는 경우에도 context 중 일부를 PCB에 저장하기도 한다. 하지만, 컨텍스트 스위칭이라고 하지 않는다. 단지 하나의 프로세스가 사용자 모드에서 커널 모드로 실행 모드만 바꾸는 것이기 때문이다.

컨텍스트 스위칭이 필요한 이유

만약 하나의 Task만 처리할 수 있을 때 먼저 처리되는 Task의 처리시간이 오래걸릴 경우, 그 시간만큼 다른 Task는 무한정 대기해야 한다.



CPU 스케줄링

스케줄러란?

- 어떤 프로세스에게 자원을 할당할지 결정하는 운영체제의 커널 모듈



프로세스 스케줄러 종류

- 장기 스케줄러
  - 어떤 프로세스를 ready queue에 보낼지, 시분할 시스템에서는 잘 안둠
- 단기 스케줄러
  - 어떤 프로세스를 실행시킬지
- 중기 스케줄러
  - 메모리에 공간이 부족한 경우 어떤 프로세스를 swap out 할지



스케줄링이란?

- 프로세서에게 필요한 자원을 어떻게 할당할 것인지 선택하는 알고리즘
- 단위 시간당 처리량을 최대화하고, 효율적으로 자원을 할당하기 위한 목적을 가지고 있다.



스케줄링 단계

- 장기 스케줄러에 의해 어떤 프로세스가 준비 큐(Ready Queue)에 삽입될지 결정한다.
  - Ready Queue란 현재 메모리 내에 있으면서 CPU에 의해 실행되기를 기다리는 프로세스의 집합
- 단기 스케줄러는 스케줄링 알고리즘에 따라 CPU를 할당할 프로세스를 선택한다.
- 선택된 프로세스는 Running 상태가 되고 작업이 끝나면 Terminated 상태가 된다.
- 중기 스케줄러는 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절한다.



스케줄링 방법

- 선점 스케줄링
  - 프로세스가 CPU를 점유하고 있어도, 우선 순위가 높은 프로세스가 오면 CPU를 빼앗을 수 있는 방식
  - 우선 순위가 높은 프로세스가 빠르게 처리할 수 있다는 장점이 있지만, 잦은 컨텍스트 스위칭으로 오버헤드가 증가한다는 단점이 있다.
  - 종류
    - 우선순위 스케줄링 : 우선순위가 높은 순서대로 처리
    - 라운드로빈 : 동일한 시간의 time quantum만큼 할당
    - Multilevel Queue : 작업을 여러 종류의 큐로 나누어 큐마다 다른 time quantum 할당
    - Multilevel-feedback Queue : Multilevel에서 time quantum을 채우면 다음 level로 내려감
- 비전섬 스케줄링
  - 프로세스가 CPU를 점유하고 있는 경우 다른 프로세스가 CPU를 빼앗지 못하는 방식
  - 중간에 가로채지 않기 때문에 응답 시간 예측이 용이하다는 장점이 있지만, 중요한 작업이 오래 기다리게 되는 경우가 발생할 수 있다는 단점이 있다.
  - 종류
    - FCFS(First Come First Served) : 큐에 도착한 순서대로 CPU 할당
    - SJF(Shortest Job Firs) : 수행시간이 짧은 것 부터 CPU 할당





교착상태(DeadLock)

교착상태(Deadlock), 기아상태(Starvation)

- 교착상태
  - 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하면서 무한정 기다리는 상황을 말한다.
- 기아상태
  - 병행 프로세스에서 프로세스가 실행되는데에 필수적인 자원을 끊임없이 사용하지 못하는 상황을 말한다.



교착상태가 발생하기 위한 조건

4가지 중 하나라도 성립하지 않으면 데드락은 발생하지 않는다.

1. 상호 배제(Mutual exclusion) : 자원은 한번에 한 프로세스만 사용할 수 있음
2. 점유 대기(Hold and wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
3. 비선점(No preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
4. 순환 대기(Circular wait) : 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함



교착상태의 해결법

1. 예방(prevention)
   교착 상태 발생 조건 중 하나를 제거하면서 해결한다 (자원 낭비 엄청 심함)
   - 상호배제 부정 : 여러 프로세스가 공유 자원 사용
   - 점유대기 부정 : 프로세스 실행전 모든 자원을 할당
   - 비선점 부정 : 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납
   - 순환대기 부정 : 자원에 고유번호 할당 후 순서대로 자원 요구
2. 회피(avoidance) - 교착 상태 발생 시 피해나가는 방법
   - 은행원 알고리즘(Banker's Algorithm)
     - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는데서 유래함
     - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있으면 자원할당, 아니면 할당을 거부하고 다른 프로세스 들이 자원을 해지할때까지 대기하는 방법
3. 탐지(Detection) & 회복
   - 은행원 알고리즘과 유사한 방식 vs 자원 할당 그래프를 통해 교착 상태를 탐지함
   - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생함
4. 회복(Recovery) - 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법
   프로세스 종료 방법
   - 교착 상태의 프로세스를 모두 중지
   - 교착 상태가 제거될 때까지 하나씩 프로세스 중지
   자원 선점 방법
   - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
   - 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점
5. 무시





세마포어(Semaphore) & 뮤텍스(Mutex)

여러 프로세스나 스레드가 공유 자원에 접근하는 것을 제어하기 위한 방법이다. 즉, 병행 처리를 위한 프로세스 동기화 방법이다.



뮤텍스

- 한 번에 한개의 권한이 있는 프로세스만 접근 가능하도록 관리하는 방법
- 임계영역에 들어갈 때 락을 걸어서 다른 프로세스가 접근하지 못하도록 하고, 임계영역에서 나와서 락을 해제한다.
      wait (mutex);
      …..
      Critical Section
      …..
      signal (mutex);
- 이진 세마포어와 같이 초기값을 1과 0으로 가진다.



ex) 화장실이 하나 뿐인 식당

1. 화장실을 가려면 카운터에서 열쇠를 받아 가야 한다.
2. 다른 사람이 와도 먼저 들어간 사람이 나올 때까지 카운터에서 열쇠를 받기 위해서 기다려야 한다.
3. 새로운 사람이 오면 똑같이 카운터에서 대기해야 한다.
4. 화장실에서 나와서 카운터에 키를 돌려놓으면, 기다리던 사람 중 맨 앞에 있던 사람이 키를 받아서 화장실을 이용한다.



세마포어

- 여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방법
- Signaling 메커니즘을 이용한다. 락을 걸지 않은 스레드도 signal을 보내서 락을 해제할 수 있다.
- 세마포어는 동기화를 위해서 wait와 signal이라는 2개의 stomic operations를 사용한다.
  - wait : 세마포어 값을 감소시킨다. 만일 값이 음수가 되면 wait를 호출한 프로세스는 블록이 된다.
  - signal : 세마포어 값을 증가시킨다. 만약 값이 양수가 아니면, wait 연산에 의해 블록된 프로세스들을 깨운다.



ex) 화장실을 좀 더 쉽게 이용할 수 있는 레스토랑. 화장실 빈 칸 수를 보여주는 전광판이 존재.

- wait를 호출하면 세마포어의 카운트를 1 줄이고, 세마포어의 카운트가 0보다 작거나 같아질 경우 락이 실행된다.



세마포어의 종류

- 유지할 수 있는 값의 범위에 따라 이진 세마포어, 범용 세마포어(카운팅 세마포어)로 구분된다.

- 이진 세마포어
  - 세마포어의 초기 값이 0또는 1만 가질 수 있는 세마포어 (뮤텍스와 비슷)

차이점

- 뮤텍스는 공유자원에 오직 1개의 프로세스만 접근할 수 있다. 하지만, 세마포어는 사마포어의 변수만큼의 프로세스가 접근할 수 있다.
- 뮤텍스는 Locking 메커니즘으로 락을 걸은 스레드만 임계 영역을 나갈 때 락을 해제할 수 있다. 하지만, 세마포어는 Signaling 메커니즘으로 락을 걸지 않은 스레드도 signal을 사용해서 락을 해제할 수 있다.
- 세마포어의 카운트를 1로 설정하면 뮤텍스처럼 사용할 수 있다.





페이징 & 세그먼테이션 (PDF)



페이지 교체 알고리즘



메모리(Memory)



파일 시스템

 

